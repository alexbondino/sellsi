<!DOCTYPE html>
<html>
<head>
    <title>Test Scroll Anti-Rebote</title>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif;
            background: linear-gradient(45deg, #f3f4f6, #e5e7eb);
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        .status-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            min-width: 200px;
        }
        .metric { margin: 5px 0; }
        .active { color: #ff6b6b; font-weight: bold; }
        .quiet { color: #51cf66; font-weight: bold; }
        .item {
            height: 200px;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: transform 0.2s ease;
        }
        .item:hover {
            transform: translateY(-2px);
        }
        .scroll-info {
            background: #667eea;
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="status-panel" id="statusPanel">
        <div class="metric">Estado: <span id="scrollStatus" class="quiet">QUIET</span></div>
        <div class="metric">Velocidad: <span id="velocity">0</span> px/ms</div>
        <div class="metric">Direcci√≥n: <span id="direction">-</span></div>
        <div class="metric">Listeners: <span id="listeners">0</span></div>
        <div class="metric">Observers: <span id="observers">-</span></div>
        <div class="metric">Calls: <span id="calls">0</span></div>
    </div>

    <div class="container">
        <div class="item scroll-info">
            <h2>üß™ Test Scroll Anti-Rebote</h2>
        </div>
        
        <div class="item">
            <div>
                <h3>‚úÖ ScrollManager Unificado</h3>
                <p>Todos los listeners coordinados en un solo RAF handler</p>
            </div>
        </div>

        <div class="item">
            <div>
                <h3>üö´ Anti-Bouncing</h3>
                <p>LazyImage observers pausados durante scroll activo</p>
            </div>
        </div>

        <div class="item">
            <div>
                <h3>‚ö° Priority System</h3>
                <p>High priority: Infinite scroll | Normal: Search bar | Low: FAB</p>
            </div>
        </div>

        <div class="item">
            <div>
                <h3>üéØ Velocity Detection</h3>
                <p>Scroll r√°pido > 2px/ms = timeouts adaptativos</p>
            </div>
        </div>

        <div class="item">
            <div>
                <h3>üìä Real-time Metrics</h3>
                <p>Monitoreo en tiempo real del estado del scroll</p>
            </div>
        </div>

        <!-- Generar m√°s items para tener scroll -->
        <script>
            for (let i = 6; i <= 30; i++) {
                document.write(`
                    <div class="item">
                        <div>
                            <h3>üì¶ Item ${i}</h3>
                            <p>Contenido de prueba para scroll. Altura fija de 200px.</p>
                        </div>
                    </div>
                `);
            }
        </script>

        <div class="item scroll-info">
            <h2>üèÅ Fin del contenido</h2>
        </div>
    </div>

    <script>
        // Simular ScrollManagerAntiRebote para testing
        class TestScrollManager {
            constructor() {
                this.listeners = new Map();
                this.isActivelyScrolling = false;
                this.stats = { totalCalls: 0, activeListeners: 0 };
                this.scrollState = { velocity: 0, direction: 'down' };
                this.lastScrollTop = 0;
                this.lastScrollTime = 0;
                this.scrollEndTimeout = null;
                
                this.handleScroll = this.handleScroll.bind(this);
                window.addEventListener('scroll', this.handleScroll, { passive: true });
                
                window.testScrollManager = this;
            }

            addListener(id, callback, options = {}) {
                this.listeners.set(id, { callback, options });
                this.stats.activeListeners = this.listeners.size;
                this.updateUI();
                return () => this.removeListener(id);
            }

            removeListener(id) {
                this.listeners.delete(id);
                this.stats.activeListeners = this.listeners.size;
                this.updateUI();
            }

            handleScroll() {
                this.stats.totalCalls++;
                
                const now = performance.now();
                const scrollTop = window.pageYOffset;
                const timeDelta = now - this.lastScrollTime;
                const scrollDelta = scrollTop - this.lastScrollTop;
                
                if (timeDelta > 0) {
                    this.scrollState.velocity = Math.abs(scrollDelta) / timeDelta;
                    this.scrollState.direction = scrollDelta > 0 ? 'down' : 'up';
                }

                const wasScrolling = this.isActivelyScrolling;
                this.isActivelyScrolling = true;
                
                if (!wasScrolling) {
                    window.dispatchEvent(new CustomEvent('scrollManagerActive'));
                }

                this.lastScrollTop = scrollTop;
                this.lastScrollTime = now;

                // Ejecutar listeners
                this.listeners.forEach(({ callback }, id) => {
                    try {
                        callback({
                            scrollTop,
                            velocity: this.scrollState.velocity,
                            direction: this.scrollState.direction,
                            isActivelyScrolling: this.isActivelyScrolling
                        });
                    } catch (e) {
                        console.warn('Error in listener', id, e);
                    }
                });

                // Detectar fin de scroll
                clearTimeout(this.scrollEndTimeout);
                this.scrollEndTimeout = setTimeout(() => {
                    this.isActivelyScrolling = false;
                    window.dispatchEvent(new CustomEvent('scrollManagerQuiet'));
                    this.updateUI();
                }, 150);

                this.updateUI();
            }

            updateUI() {
                document.getElementById('scrollStatus').textContent = this.isActivelyScrolling ? 'ACTIVE' : 'QUIET';
                document.getElementById('scrollStatus').className = this.isActivelyScrolling ? 'active' : 'quiet';
                document.getElementById('velocity').textContent = this.scrollState.velocity.toFixed(2);
                document.getElementById('direction').textContent = this.scrollState.direction.toUpperCase();
                document.getElementById('listeners').textContent = this.stats.activeListeners;
                document.getElementById('calls').textContent = this.stats.totalCalls;
            }
        }

        // Simular Observer Pool
        class TestObserverPool {
            constructor() {
                this.observedElements = 0;
                this.isPaused = false;
                
                window.addEventListener('scrollManagerActive', () => {
                    this.isPaused = true;
                    this.updateUI();
                });
                
                window.addEventListener('scrollManagerQuiet', () => {
                    this.isPaused = false;
                    this.updateUI();
                });
            }

            observe(element, callback) {
                this.observedElements++;
                this.updateUI();
                return () => {
                    this.observedElements--;
                    this.updateUI();
                };
            }

            updateUI() {
                const status = this.isPaused ? 'PAUSED' : 'ACTIVE';
                document.getElementById('observers').textContent = `${this.observedElements} (${status})`;
            }
        }

        // Inicializar
        const scrollManager = new TestScrollManager();
        const observerPool = new TestObserverPool();

        // Agregar algunos listeners de ejemplo
        scrollManager.addListener('infinite-scroll', (data) => {
            // Simular infinite scroll logic
        }, { priority: 1 });

        scrollManager.addListener('search-bar', (data) => {
            // Simular search bar behavior
        }, { priority: 0 });

        scrollManager.addListener('fab-button', (data) => {
            // Simular FAB visibility
        }, { priority: -1 });

        // Simular algunos observers
        for (let i = 0; i < 8; i++) {
            observerPool.observe(document.body, () => {});
        }

        console.log('üß™ Test ScrollManager Anti-Rebote cargado');
        console.log('üìä Haz scroll para ver las m√©tricas en tiempo real');
        console.log('üîç Observa c√≥mo se pausan los observers durante scroll activo');
    </script>
</body>
</html>
