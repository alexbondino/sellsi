/**
 * @jest-environment jsdom
 * 
 * Tests para adminAuthService
 * Cubre: Login, logout, 2FA, sesi√≥n, recuperaci√≥n de contrase√±a
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals'

// Mock functions que simular√°n el comportamiento del servicio
const mockLoginAdmin = jest.fn()
const mockLogoutAdmin = jest.fn()
const mockValidateAdmin2FA = jest.fn()
const mockSetup2FA = jest.fn()
const mockDisable2FA = jest.fn()
const mockGetCurrentSession = jest.fn()
const mockIsAdminAuthenticated = jest.fn()
const mockRequestPasswordReset = jest.fn()
const mockVerifyResetToken = jest.fn()

// Objeto que simula el servicio
const adminAuthService = {
  loginAdmin: mockLoginAdmin,
  logoutAdmin: mockLogoutAdmin,
  validateAdmin2FA: mockValidateAdmin2FA,
  setup2FA: mockSetup2FA,
  disable2FA: mockDisable2FA,
  getCurrentSession: mockGetCurrentSession,
  isAdminAuthenticated: mockIsAdminAuthenticated,
  requestPasswordReset: mockRequestPasswordReset,
  verifyResetToken: mockVerifyResetToken
}

describe('adminAuthService - Autenticaci√≥n', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('loginAdmin()', () => {
    it('‚úÖ debe autenticar admin con credenciales v√°lidas', async () => {
      const mockSession = {
        user: { id: 'admin-123', email: 'admin@sellsi.com' },
        access_token: 'token-123'
      }

      mockLoginAdmin.mockResolvedValue({
        success: true,
        session: mockSession,
        requires2FA: false
      })

      const result = await adminAuthService.loginAdmin('admin@sellsi.com', 'password123')

      expect(result.success).toBe(true)
      expect(result.session).toBeDefined()
      expect(result.session.user.email).toBe('admin@sellsi.com')
    })

    it('‚ùå debe rechazar credenciales inv√°lidas', async () => {
      mockLoginAdmin.mockResolvedValue({
        success: false,
        error: 'Credenciales inv√°lidas'
      })

      const result = await adminAuthService.loginAdmin('wrong@email.com', 'wrongpass')

      expect(result.success).toBe(false)
      expect(result.error).toContain('Credenciales')
    })

    it('üîê debe requerir 2FA cuando est√° habilitado', async () => {
      mockLoginAdmin.mockResolvedValue({
        success: true,
        requires2FA: true,
        session: null
      })

      const result = await adminAuthService.loginAdmin('admin@sellsi.com', 'password123')

      expect(result.success).toBe(true)
      expect(result.requires2FA).toBe(true)
      expect(result.session).toBeNull()
    })

    it('‚ö†Ô∏è debe validar formato de email', async () => {
      mockLoginAdmin.mockResolvedValue({
        success: false,
        error: 'Email inv√°lido'
      })

      const result = await adminAuthService.loginAdmin('not-an-email', 'password123')

      expect(result.success).toBe(false)
    })

    it('‚ö†Ô∏è debe requerir contrase√±a', async () => {
      mockLoginAdmin.mockResolvedValue({
        success: false,
        error: 'Contrase√±a requerida'
      })

      const result = await adminAuthService.loginAdmin('admin@sellsi.com', '')

      expect(result.success).toBe(false)
    })
  })

  describe('2FA - Autenticaci√≥n de dos factores', () => {
    it('‚úÖ debe configurar 2FA correctamente', async () => {
      const mockQRCode = 'data:image/png;base64,iVBOR...'
      const mockSecret = 'JBSWY3DPEHPK3PXP'

      adminAuthService.setup2FA.mockResolvedValue({
        success: true,
        qrCode: mockQRCode,
        secret: mockSecret
      })

      const result = await adminAuthService.setup2FA('admin-123')

      expect(result.success).toBe(true)
      expect(result.qrCode).toBeDefined()
      expect(result.secret).toBeDefined()
    })

    it('‚úÖ debe validar c√≥digo 2FA correcto', async () => {
      adminAuthService.validateAdmin2FA.mockResolvedValue({
        success: true,
        valid: true
      })

      const result = await adminAuthService.validateAdmin2FA('admin-123', '123456')

      expect(result.success).toBe(true)
      expect(result.valid).toBe(true)
    })

    it('‚ùå debe rechazar c√≥digo 2FA incorrecto', async () => {
      adminAuthService.validateAdmin2FA.mockResolvedValue({
        success: false,
        valid: false,
        error: 'C√≥digo inv√°lido'
      })

      const result = await adminAuthService.validateAdmin2FA('admin-123', '000000')

      expect(result.success).toBe(false)
      expect(result.valid).toBe(false)
    })

    it('‚è±Ô∏è debe rechazar c√≥digo 2FA expirado', async () => {
      adminAuthService.validateAdmin2FA.mockResolvedValue({
        success: false,
        valid: false,
        error: 'C√≥digo expirado'
      })

      const result = await adminAuthService.validateAdmin2FA('admin-123', '123456')

      expect(result.success).toBe(false)
      expect(result.error).toContain('expirado')
    })

    it('‚úÖ debe deshabilitar 2FA con confirmaci√≥n', async () => {
      adminAuthService.disable2FA.mockResolvedValue({
        success: true,
        message: '2FA deshabilitado correctamente'
      })

      const result = await adminAuthService.disable2FA('admin-123', '123456')

      expect(result.success).toBe(true)
    })
  })

  describe('getCurrentSession()', () => {
    it('‚úÖ debe obtener sesi√≥n activa', async () => {
      const mockSession = {
        user: { id: 'admin-123', email: 'admin@sellsi.com' },
        access_token: 'token-123',
        expires_at: Date.now() + 3600000
      }

      adminAuthService.getCurrentSession.mockResolvedValue({
        success: true,
        session: mockSession
      })

      const result = await adminAuthService.getCurrentSession()

      expect(result.success).toBe(true)
      expect(result.session).toBeDefined()
      expect(result.session.user.id).toBe('admin-123')
    })

    it('‚ùå debe retornar null si no hay sesi√≥n', async () => {
      adminAuthService.getCurrentSession.mockResolvedValue({
        success: false,
        session: null
      })

      const result = await adminAuthService.getCurrentSession()

      expect(result.success).toBe(false)
      expect(result.session).toBeNull()
    })

    it('‚è±Ô∏è debe detectar sesi√≥n expirada', async () => {
      adminAuthService.getCurrentSession.mockResolvedValue({
        success: false,
        session: null,
        error: 'Sesi√≥n expirada'
      })

      const result = await adminAuthService.getCurrentSession()

      expect(result.success).toBe(false)
      expect(result.error).toContain('expirada')
    })
  })

  describe('logoutAdmin()', () => {
    it('‚úÖ debe cerrar sesi√≥n correctamente', async () => {
      adminAuthService.logoutAdmin.mockResolvedValue({
        success: true
      })

      const result = await adminAuthService.logoutAdmin()

      expect(result.success).toBe(true)
    })

    it('‚úÖ debe limpiar sesi√≥n local', async () => {
      adminAuthService.logoutAdmin.mockResolvedValue({
        success: true
      })

      await adminAuthService.logoutAdmin()
      
      adminAuthService.isAdminAuthenticated.mockReturnValue(false)
      const isAuth = adminAuthService.isAdminAuthenticated()

      expect(isAuth).toBe(false)
    })
  })

  describe('Recuperaci√≥n de contrase√±a', () => {
    it('‚úÖ debe enviar email de recuperaci√≥n', async () => {
      adminAuthService.requestPasswordReset.mockResolvedValue({
        success: true,
        message: 'Email enviado'
      })

      const result = await adminAuthService.requestPasswordReset('admin@sellsi.com')

      expect(result.success).toBe(true)
    })

    it('‚ùå debe rechazar email no registrado', async () => {
      adminAuthService.requestPasswordReset.mockResolvedValue({
        success: false,
        error: 'Email no encontrado'
      })

      const result = await adminAuthService.requestPasswordReset('noexiste@email.com')

      expect(result.success).toBe(false)
    })

    it('‚úÖ debe verificar token de reset v√°lido', async () => {
      adminAuthService.verifyResetToken.mockResolvedValue({
        success: true,
        valid: true
      })

      const result = await adminAuthService.verifyResetToken('valid-token-123')

      expect(result.success).toBe(true)
      expect(result.valid).toBe(true)
    })

    it('‚ùå debe rechazar token inv√°lido', async () => {
      adminAuthService.verifyResetToken.mockResolvedValue({
        success: false,
        valid: false,
        error: 'Token inv√°lido o expirado'
      })

      const result = await adminAuthService.verifyResetToken('invalid-token')

      expect(result.success).toBe(false)
      expect(result.valid).toBe(false)
    })
  })

  describe('Seguridad y validaciones', () => {
    it('üîí debe prevenir SQL injection en login', async () => {
      const maliciousEmail = "admin' OR '1'='1"
      
      adminAuthService.loginAdmin.mockResolvedValue({
        success: false,
        error: 'Email inv√°lido'
      })

      const result = await adminAuthService.loginAdmin(maliciousEmail, 'pass')

      expect(result.success).toBe(false)
    })

    it('üõ°Ô∏è debe rate-limit intentos de login', async () => {
      adminAuthService.loginAdmin.mockResolvedValue({
        success: false,
        error: 'Demasiados intentos. Espere 5 minutos.'
      })

      // Simular 5 intentos fallidos
      for (let i = 0; i < 5; i++) {
        await adminAuthService.loginAdmin('admin@sellsi.com', 'wrong')
      }

      const result = await adminAuthService.loginAdmin('admin@sellsi.com', 'password')

      expect(result.success).toBe(false)
      expect(result.error).toContain('intentos')
    })

    it('üîê debe rechazar contrase√±as d√©biles', async () => {
      adminAuthService.loginAdmin.mockResolvedValue({
        success: false,
        error: 'Contrase√±a debe tener al menos 8 caracteres'
      })

      const result = await adminAuthService.loginAdmin('admin@sellsi.com', '123')

      expect(result.success).toBe(false)
    })
  })
})
