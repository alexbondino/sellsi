"""
IterationCalculator - Responsabilidad: C√°lculo de iteraciones y meses

Principio de Responsabilidad √önica (SRP):
- Determinar cu√°ntas iteraciones se necesitan (n)
- Calcular qu√© mes corresponde a cada iteraci√≥n
- L√≥gica de negocio: si d√≠a_inicio cuenta o no
"""

from datetime import datetime
from dateutil.relativedelta import relativedelta
from typing import Callable
from .date_calculator import DateCalculator


class IterationCalculator:
    """
    Calculador especializado en determinar iteraciones.
    
    Responsabilidades:
    - Calcular n√∫mero de iteraciones necesarias
    - Determinar mes correspondiente a cada iteraci√≥n
    - Aplicar regla de negocio: d√≠a_inicio <= √∫ltimo_d√≠a_h√°bil
    """
    
    # Mapeo de nombres de meses en espa√±ol
    MESES_ES = {
        "enero": 1, "febrero": 2, "marzo": 3, "abril": 4,
        "mayo": 5, "junio": 6, "julio": 7, "agosto": 8,
        "septiembre": 9, "octubre": 10, "noviembre": 11, "diciembre": 12
    }
    
    def __init__(self, log_callback: Callable, date_calculator: DateCalculator):
        """
        Args:
            log_callback: Funci√≥n para logging
            date_calculator: Instancia de DateCalculator para c√°lculos de fechas
        """
        self.log = log_callback
        self.date_calc = date_calculator
    
    def calcular_numero_iteraciones(
        self, 
        fecha_inicio: datetime, 
        mes_vencimiento_str: str
    ) -> int:
        """
        Calcula cu√°ntas iteraciones se necesitan.
        
        Regla de negocio:
        - Si d√≠a_inicio <= √∫ltimo_d√≠a_h√°bil del mes_inicio ‚Üí mes inicio CUENTA
        - Siempre se incluyen todos los meses hasta mes_vencimiento
        
        Args:
            fecha_inicio: Fecha de inicio del c√°lculo
            mes_vencimiento_str: String como "Diciembre 2025"
            
        Returns:
            N√∫mero de iteraciones (n)
        """
        # Parsear mes_vencimiento
        mes_venc, a√±o_venc = self._parsear_mes_vencimiento(mes_vencimiento_str)
        
        # Calcular diferencia de meses
        meses_totales_vencimiento = a√±o_venc * 12 + mes_venc
        meses_totales_inicio = fecha_inicio.year * 12 + fecha_inicio.month
        num_meses_base = meses_totales_vencimiento - meses_totales_inicio
        
        # Calcular √∫ltimo d√≠a del mes de inicio (sin considerar d√≠as h√°biles)
        from calendar import monthrange
        ultimo_dia_mes_inicio = monthrange(fecha_inicio.year, fecha_inicio.month)[1]
        
        # Aplicar regla de negocio
        if fecha_inicio.day <= ultimo_dia_mes_inicio:
            num_iteraciones = num_meses_base + 1
            self.log(
                f"[IterCalc] üìä D√≠a inicio ({fecha_inicio.day}) <= "
                f"√∫ltimo d√≠a del mes ({ultimo_dia_mes_inicio}) ‚Üí Mes inicio CUENTA", 
                level="INFO"
            )
        else:
            num_iteraciones = num_meses_base
            self.log(
                f"[IterCalc] üìä D√≠a inicio ({fecha_inicio.day}) > "
                f"√∫ltimo d√≠a del mes ({ultimo_dia_mes_inicio}) ‚Üí Mes inicio NO cuenta", 
                level="INFO"
            )
        
        self.log(f"[IterCalc] üî¢ N√∫mero de iteraciones: {num_iteraciones}", level="INFO")
        return num_iteraciones
    
    def calcular_mes_iteracion(
        self, 
        fecha_inicio: datetime, 
        numero_iteracion: int
    ) -> datetime:
        """
        Calcula qu√© mes corresponde a una iteraci√≥n espec√≠fica.
        
        Args:
            fecha_inicio: Fecha de inicio del c√°lculo
            numero_iteracion: N√∫mero de iteraci√≥n (1, 2, 3, ...)
            
        Returns:
            datetime representando el primer d√≠a del mes correspondiente
        """
        # Calcular √∫ltimo d√≠a del mes de inicio (sin considerar d√≠as h√°biles)
        from calendar import monthrange
        ultimo_dia_mes_inicio = monthrange(fecha_inicio.year, fecha_inicio.month)[1]
        
        # Determinar mes base
        if fecha_inicio.day <= ultimo_dia_mes_inicio:
            # Empezar desde el mes de inicio
            mes_base = datetime(fecha_inicio.year, fecha_inicio.month, 1)
        else:
            # Empezar desde el mes siguiente
            mes_base = datetime(fecha_inicio.year, fecha_inicio.month, 1) + relativedelta(months=1)
        
        # Sumar (iteracion - 1) meses
        mes_iteracion = mes_base + relativedelta(months=(numero_iteracion - 1))
        
        return mes_iteracion
    
    def _parsear_mes_vencimiento(self, mes_vencimiento_str: str) -> tuple[int, int]:
        """
        Parsea un string como "Diciembre 2025" a (mes, a√±o).
        
        Args:
            mes_vencimiento_str: String formato "Mes A√±o"
            
        Returns:
            Tupla (mes: int, a√±o: int)
        """
        partes = mes_vencimiento_str.lower().split()
        mes_nombre = partes[0]
        a√±o = int(partes[1])
        mes = self.MESES_ES.get(mes_nombre, 1)
        
        return mes, a√±o
